> # 2019.03.20

[TOC]

# 잡설





# 알고리즘 보충수업

## DFS (깊이 우선 탐색)

1. 시작 정점 v를 결정하여 방문
2. 정점 v에 인접한 정점 중에서 방문하지 않은 정점이 w 있으면, v를 stack에 push하고 정점 w를 방문하고 이 과정을 반복
3. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 과정 2) 반복
4. 스택이 공백이 될 때까지 위 과정을 반복



pdf에 준 dfs 관련 sudo code는 별로 좋은 모양이 아니니 다른 걸 참고하길 바람.



사이클을 찾을 때 유용하다.

최단 거리를 찾기엔 나쁘다. 운의 비중이 크다.



BFS는 일단 다 큐에 집어 넣고 하기 때문에 불필요한 반복이 들어가기도 한다.



강사님 코드 스타일로는 반드시 stack에 시작점이 2번 들어감

```python
def DFS(v):  # v : 시작점
    S = []  # 스택
    visit = [False] * (V + 1)  # 방문 표시
    # 시작점을 방문하고 스택에 push
    visit[v] = True
    print(v, end=' ')
    S.append(v)

    while len(S) > 0:  # 빈 스택이 아닐 동안
        # v: 현재 방문 정점
        # v의 방문 하지 않은 인접 정점(w) 하나 찾는다
        for w in G[v]:
            if not visit[w]:
                visit[w] = True
                print(w, end=' ')
                S.append(v)
                v = w
                break  # DFS는 한 번 찾으면 탈출해야 한다.
        else:
            v = S.pop()


V, E = map(int, input().split())
G = [[] for _ in range(V + 1)]
for i in range(E):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)  # 무향 그래프

DFS(1)
```



재귀를 이용하여 구현

```python
def DFS(v):  # v : 현재 방문 정점
    visit[v] = True
    print(v, end=' ')
    # 방문하지 않은 인접 정점을 찾아서 방문
    for w in G[v]:
        if not visit[w]:
            DFS(w)
            
visit = [False] * (V + 1)
DFS(1)
```



다음에는 사다리와 미로탐색을 DFS로 해보겠다.



---

# 컴퓨팅 사고력 과제 리뷰

### 4 - 8

**강사님**

근사



**최정화**

적분



### 5 - 3, 4

**임동영**

쪼개다보니 된다.

시간 복잡도 풀음



**강사님**





### 6 - 3

DP 기본내용





# APS Python 응용_1

**<잡설>**

B반(Java)의 커리큘럼 순서는 설계기법이 먼저 나오고 자료구조가 더 늦게 나온다.

완전검색 + [그리드, 분할정복, 백트래킹(가지치기), DP] ==> NP ==> 근사

참고로 A, B반 모두 자료는 2014년에 만들어진 것이니, 이 점을 감안해라.

----

## Start

### SW 문제해결

1. SW 문제 해결 역량이 무엇인가 이해하고 역량을 강화하는 방법을 이해한다.
2. 효율적인 알고리즘의 필요성 이해하고, 알고리즘 성능 측정 방법 중 하나인 시간복잡도에 대해 이해한다.
3. 표준 입출력 방법에 대해 이해한다.
4. 비트 수준의 연산과 알고리즘에 대해 이해한다.
5. 컴퓨터에서의 실수 표현 방법에 대해 이해한다.



* 프로그래밍 "잘하는 사람과 못하는 사람의 생산성 차이가 스무 배" - [Thinking in java]의 저자 브루스 에켈

* 프로그래밍하기 위한 제약 조건과 요구사항

  * 프로그래밍 언어의 특성

    Python은 High-Level의 라이브러리로 prototype을 빨리 짜기 위한 언어. 이런 특성 때문에 pro 시험에서는 python을 취급하지 않는다.

  * 프로그램이 동작할 HW와 OS에 관한 지식

    컴퓨터 성능이 극한인 상황에서 어떻게 코딩해야하는지 알기 위해서는 HW, OS의 특성 이해 필요. 게다가 HW, OS는 항상 개발하고 있기 때문에 공부가 지속적으로 필요.

  * 라이브러리들의 유의 사항들

  * 프로그램이 사용할 수 있는 최대 메모리

  * 사용자 대응 시간 제한

  * 재사용성이 높은 간결한 코드

  * ...

프로그래밍 언어의 가계도를 참고해보자.



아래는 어떤 하얀 책에서 발췌한 내용.

* SW 문제 해결 역량이란 무엇인가?
  * 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
  * 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력
  * 문제 해결 역량은 추상적인 기술
    - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
    - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
  * 문제 해결 역량을 향상시키기 위해서는 훈련이 필요



* 문제 해결 능력을 훈련하기 위해서는
  * 일부 새로운언어, 프레임웤, 개발 방법론만으로는 불충분. 이들을 조합해 나가는 방법을 배워야 한다.
  * 무작정 많은 경험이 해결해주진 않는다. 경험에서는 문제해결능력을 개발 할 수 있는 상황이 항상 주어지는 것이 아니며 또한 그런 상황에서 자기 개발을 하기는 쉽지 않다.
  * 상황을 인위적으로 만들어 훈련해야 한다. **저지사이트가 각광받은 이유**. 즉 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시켜야한다.



- 문제 해결 과정
  1. 문제 읽고 이해
  2. 문제를 익숙한 용어로 재정의
  3. 해결 계획을 세움
  4. 계획 검증
  5. 프로그램 구현
  6. 개선할 방법 탐색



6번 관련 이야기

포커스 개념(일종의 방법론)으로 반복하는 방법. 단계별로 검증, 개선. 느리다는 단점.

페스트 프로토타입 - 일단 짜고 돌리고 틀린 부분 찾기

이보다 더 빠른 방법론이 ......



하지만 우리는 포커스 개념으로 차근차근해야 한다.

TC를 넣어서 확인하는게 번거로워 보여도 늦지 않음.



자가검증을 자주 해야 한다. 특히 시험장에서는 집중력을 발휘하여 정확한 검증을 할 줄 알아야 한다. 항상 틀릴 수 있다는 생각을 해야 한다.

시간이 되면 시간 복잡도 등이 최선일까라는 의문을 던질 줄 알아야 한다.



- 문제 해결 전략

  - 직관과 체계적인 접근

    정확성은 떨어지지만 이것만큼 빠른게 없다

- 체계적인 접근을 위한 질문들

  - 비슷한 문제를 풀어본 적이 있는가?
  - 단순한 방법에서 시작할 수 있을가?
  - 문제를 단순화 할 수 있을까?
  - 그림으로 그려 볼 수 있을까?
  - 수식으로 표현 할 수 있을까?
  - 문제를 분해 할 수 있을까?
  - 뒤에서부터 생각해서 문제를 풀 수 있을까?
  - 특정 형태의 답만을 고려할 수 있을까?



### 복잡도 분석

시간 복잡도를 통해 디자인과 코딩 모양새를 예측할 수 있다.

log n 인거 보니 분할 정복인가 보구나~

* 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.

알고리즘을 측정하는 방법은 5가지 있다.

효율성, 정확성, 재사용성

최적이냐는 메모리, 시간 2가지 요소를 고려한다.



* 알고리즘의 효율

  - 공간적 효율성과 시간적 효율성

    - 공간적 효율성은 연산량 대비 적은 메모리
    - 시간적 효율성은 연상량 대비 적은 시간
    - 효율성을 뒤집어 표현하면 복잡도(Complexity)

  - 시간 복잡도 분석

    - 하드웨어 환경에 따라 처리시간 달라짐

      부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무, 입출력 장비의 성능, 공유여부

    - 소프트웨어 환경에 따라 처리시간 달라짐

      프로그램 언어의 종류, 운영체제, 컴파일러의 종류

    - 환경적 차이로 분석이 어렵다.

로컬보다 저지사이트의 서버가 더 빠르게 돌려준다.



* 복잡도의 점근적 표기
  - 시간 (또는 공간)복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.
  - 이를 단순한 함수로 표현하기 위해 점근적 표기 (Asymptotic Notation)을 사용
  - 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
    - O(Big-Oh) 표기
    - 오메가(Big-Omega) 표기
    - 세타(Big-Theta) 표기



* Big Oh 표기
  - 점근적 상한을 나타낸다.
  - 다항식의 최고차항만 계수 없이 취한다.
  - n0 가 존재할 때, cO(f(n)) > f(n) 인 상수 c가 항상 존재해야 한다.



* Big Omega
  * 점근적 하한을 나타낸다.
  * 다항식의 최고차항만 계수 없이 취한다.
  * 최소한 이만한 시간이 걸림



* Theta
  - Big-Oh, Big-Omega 표기가 같은 경우에 사용
  - 표기법과 동일한 증가율을 가진다는 의미



이진검색 O(log n)

순차검색 O(n)

버블, 힙, 힉 정렬 : O(nlogn) + 다익스트라

O(n^3) : 플로이드-워셔 알고리즘, 그래프이면서 DP. 그리드 방식을 사용.

다익스트라가 한 정점에서 다른 정점의 최단거리라면, 플로이드 워셔는 모든 정점에서 모든 정점까지 최단거리 구한다.

플로이드 워셔는 코드가 4줄이면 충분. 굉장히 알고리즘이 압축됨.

O(2^n) : 부분집합. 배낭문제

O(n!) : 순열, TSP 문제.



근사로 하는 이유 : 백트래킹, DP 등을 총 동원해도 몇 개 못 줄인다. 그래서 근사로 두고 추려서 간 것이다. AI도 크게 보면 근사로 답을 내는 것이다.



O(1) : 해싱



### 표준 입출력 방법

할 얘기 없음.

evaluated된 값 입력 : eval(input())

정해진 format으로... 모르신댄다.



* 파일의 내용을 표준 입력을 읽어오는 방법
  - import sys
  - sys.stdin = open("a.txt", "r")
  - sys.stdout = open("output.txt", "w")



많은 입 출력을 파일로 보관할 때 유용



### 비트 연산

binary digit 줄여서 bit

| 연산자 |                   연산자의 기능                    |
| :----: | :------------------------------------------------: |
|  `&`   |                비트단위로 AND 연산                 |
|  `|`   |                 비트단위로 OR 연산                 |
|  `^`   |                비트단위로 XOR 연산                 |
|  `~`   |      단항 연산자로 피연자의 모든 비트를 반전       |
|  `<<`  | 피연산자의 비트 열을 왼쪽 이동 빈자리는 0으로 채움 |
|  `>>`  |          피연산자의 비트 열을 오른쪽 이동          |



보수

bit로 음수를 표현하기 위한 표기법

1. 절대부호표기법

   맨 앞자리가 0이면 양수, 1이면 음수. 그 뒤는 똑같이 읽는다. 0표기 방법이 2개가 됨. 덧셈 등 할 때 오버플로우 생겼을 때 대응 설계가 너무 복잡해서 쓰지 않음.

2. 보수 표현 (complent)

   8 - 6 을 할 때, -6의 보수인 +4로 바꾸고 자리수는 1자리만 취한다. 그러면 똑같이 8 + 4 => 2 라는 결과가 나온다. (2의 보수) 보수끼리 그대로 더하면 정확하게 0이 됨.

   -6의 보수를 9를 기준으로 잡아서 +3으로 바꿈. 그래서 8 + 3 +1을 해준다. (1의 보수)

   1의 보수는 후처리가 있어서 대부분 2의 보수를 선호



### 연습문제 1

**내 코드**

```python
bitnums = ['0000000111', '1000000110', '0000011110', '0110000110', '0001111001', '1110011111', '1001100111']

for b in bitnums:
    cnt_x = 0
    nums_x = 0
    for x in range(6, -1, -1):
        nums_x += int(b[x]) * (2**cnt_x)
        cnt_x += 1
    
    cnt_y = 0
    nums_y = 0
    for y in range(9, 2, -1):
        nums_y += int(b[y]) * (2**cnt_y)
        cnt_y += 1
    print(nums_x, nums_y)
```

문제 자체를 잘못 이해한 듯 하다.



**강사님**

```python
arr = '0000000111100000011000000111100110000110000111100111100111111001100111'

t = 0
for i in range(len(arr)):
    t = t * 2 + int(arr[i])
    if (i+1) % 7 == 0:
        print(t, end=' ')
        t = 0
```



비트 연산 예제2

0x10 => 16진수

여기있는 ?는 하나도 이상한건 없다. 그냥 역순이란 것 뿐

c언어는 int 를 쪼갯 읽을 수 있다. 4byte메모리를 1byte 단위로 직접 접근 가능.

하지만 파이썬은 인터프린터가 감싸고 있어서 그게 불가능.

강사님이 보여준 c코드는 같은 코드여도 어느 머신이냐 따라 정수가 나오기도 하고 다른게 나오기도 한다. 머신마다 역순, 정순으로 넣는게 다르기 때문이다.

역순이 당연하다???



**pdf에 중대한 오류!**



엔디안 확인 코드로 보면 항상 little endian이라는데 구라임. 머신마다 달라야 함.

c코드로 보면 다르다.

파이썬 그 코드는 little endian, big endian 나눌 수 없다. 애초에 확인이 안 됨. 항상 little 일 수밖에 없다.



아키텍쳐에 따라 엔디안 다르고 성능 차이가 있다곤 하는데 프로그래머 입장에선 알바 아니다.

하지만 4byte int의 중간을 바꾸고 싶을 때가 온다면, 반드식 엔디안을 고려해야 한다.



비트연산 예제4도 구라!!



예제5도 구라

exclusive or를 2번 하면 원래데로 돌아온다.



---

## 진수

mapping table 이용하여 진수를 오갈 수 있다. 몇 비트로 끊던간에.



음의 정수 표현 방법



### 연습문제 2



**내 코드**

```python
hexadecimal = '0F97A3'
binary = ""

def make_bin(n):
    result = ""
    for j in range(3, -1, -1):
        result += "1" if n & (1 << j) else "0"
    return result
    

def bin_to_deci(bin):
    ans = []
    length = len(bin)
    a = length // 7
    b = length % 7
    for x in range(a):
        deci = 0
        cnt = 0
        for y in range(6+7*x, -1+7*x, -1):
            if bin[y] == '1':
                deci += 2**(cnt)
            cnt += 1
        ans.append(deci)
    deci = 0
    cnt = 0
    for z in range(1, b+1):
        if bin[-z] == '1':
                deci += 2**(cnt)
        cnt += 1
    ans.append(deci)

    return ans
    

for h in hexadecimal:
    if h.isdigit():
        binary += make_bin(int(h))
    else:
        binary += make_bin(ord(h) - ord('A') + 10)

print(binary)

answer = bin_to_deci(binary)
print(answer)
```



**강사님**

2가지 방식으로 구현하고 실행속도 비교.

1. replace를 이용해 16진수를 2진수로 convert
2. 직접 mapping을 만들어서 convert

replace를 이용한 방법이 더 빨랐다.

```python
import time

st = time.time()
arr = '01D06079861D79F99F'

# arr = arr * 100000

arr = arr.replace('0', '0000')
arr = arr.replace('1', '0001')
arr = arr.replace('2', '0010')
arr = arr.replace('3', '0011')
arr = arr.replace('4', '0100')
arr = arr.replace('5', '0101')
arr = arr.replace('6', '0110')
arr = arr.replace('7', '0111')
arr = arr.replace('8', '1000')
arr = arr.replace('9', '1001')
arr = arr.replace('A', '1010')
arr = arr.replace('B', '1011')
arr = arr.replace('C', '1100')
arr = arr.replace('D', '1101')
arr = arr.replace('E', '1110')
arr = arr.replace('F', '1111')

t = 0
for i in range(len(arr)):
    t = t * 2 + int(arr[i])
    if (i+1) % 7 == 0:
        print(t, end=' ')
        t = 0

print(time.time() - st)
print()


st = time.time()
arr1 = '01D06079861D79F99F'

# arr1 = arr1 * 100000

table = [[0, 0, 0, 0],
         [0, 0, 0, 1],
         [0, 0, 1, 0],
         [0, 0, 1, 1],
         [0, 1, 0, 0],
         [0, 1, 0, 1],
         [0, 1, 1, 0],
         [0, 1, 1, 1],
         [1, 0, 0, 0],
         [1, 0, 0, 1],
         [1, 0, 1, 0],
         [1, 0, 1, 1],
         [1, 1, 0, 0],
         [1, 1, 0, 1],
         [1, 1, 1, 0],
         [1, 1, 1, 1]]

arr = [0] * (len(arr1)*4)

for i in range(len(arr1)):
    if arr1[i] <= '9':
        idx = ord(arr1[i]) - ord('0')
    else:
        idx = ord(arr1[i]) - ord('A') + 10
    for j in range(4):
        arr[i * 4 + j] = table[idx][j]

t = 0
for i in range(len(arr)):
    t = t * 2 + int(arr[i])
    if (i+1) % 7 == 0:
        print(t, end=' ')
        t = 0
print(time.time() - st)
```





---

## 실수

파이썬은 동적으로 int, float 공간 잡기 때문에 선언할 때 굳이 타입을 꼭 서야하진 않는다.

하지만 나머지 언어들은 무조건 int, float를 선언해야 한다.



float 을 메모리에 넣는 방법

고정소수점 : 4byte를 반으로 쪼개서 정수, 소수 담당을 한다.

한쪽으로 치우친 float을 받기 어렵고, 공간이 비효율적이다.



그래서 반대개념. float number 둥둥 떠다닌다??

소수점 이하 4자리를 10진수로 변환한다. 곱하기 2 하면서 정수가 나오면 1, 안나오면 0을 붙여 4자리 2진수로 표현 가능. 근데 모양새가 소수일 때랑 같다.



1001.0011 을 소수점 이동시킨다 => 1.0010011

얘는 가수라고 부른다. 그리고 얼만큼 옮겼는지 표현해줄 수가 필요

1.0010011 * 2^3 이렇게 지수와 가수로 표현하면 효과적으로 float 저장 가능

마지막은 항상 0을 심는다... 왜??

지수부분은 2^-3 도 가능.





0.1을 10진수로 변환하려면 무한루프에 빠지게 된다.

그럼 넣을 수 있을 만큼 넣은 후 마지막 자리에서 반올림. 그래서 정확한 값이 아니라 근사값.



```python
x = 3 / 10
y = 0.1 * 3
print(x, y)
# 0.3 0.30000000000004
```

x와 y는 같은 값이 안 나온다.

그리고 근사값이 처음엔 오차가 작아도, 누적되면 오차가 크다.

삼성 pro문제는 이런 것도 고려해야 한다. 예를 들어 `|x - y| < 10**(-9)` 기준으로 같다고 처리한다.

무슨 책을 봐라. 1장에 나온다.

그럼 어디까지 믿을 수 있느냐? 32bit는 c나 java 이야긴데, 이 정도까진 믿을 수 있다. 오차가 없다고 봐도 된다. 하지만 python은 얘를 4 byte로 넣는게 아니라 simulate를 돌린다는데... 강사님이 확신하시진 않다.

python은 실수 범위가 어마무시하게 많다. 인터프린터가 알아서 해주겠다는 의도는 좋은데, 어쨋건 프로그래머가 대가를 치룰 수 있다.





질문결과

float이 더 작음 double이 더큼

상수는 무조건 double에 넣어서 연산에 용이하게

가수의 맨 앞자리는 1이지만 얘를 생략하고 차라리 소수 파트 1 더 늘림



### 연습문제3



**내 코드**

```python
secret_code = {
    '001101': 0,
    '010011': 1,
    '111011': 2,
    '110001': 3,
    '100011': 4,
    '110111': 5,
    '001011': 6,
    '111101': 7,
    '011001': 8,
    '101111': 9,
}    

arr = "0DEC"
binary = ""
for a in arr:
    if a.isdigit():
        for _ in range(3, -1, -1):
            binary += '1' if int(a) & (1 << _) else "0"
    else:
        hexi = ord(a) - ord('A') + 10
        for _ in range(3, -1, -1):
            binary += '1' if int(hexi) & (1 << _) else "0"

print(binary)

idx = 0
ans = []
while idx < len(binary):
    if binary[idx:idx+6] in secret_code:
        ans.append(secret_code[binary[idx:idx+6]])
        idx += 6
    else:
        idx += 1

print(ans)
```



**강사님**

`replace()` 메소드로 16진수를 2진수로 변경.

패턴 보이면 그때부터 번역.

```python
arr = '0269FAC9A0'

arr = arr.replace('0', '0000')
arr = arr.replace('1', '0001')
arr = arr.replace('2', '0010')
arr = arr.replace('3', '0011')
arr = arr.replace('4', '0100')
arr = arr.replace('5', '0101')
arr = arr.replace('6', '0110')
arr = arr.replace('7', '0111')
arr = arr.replace('8', '1000')
arr = arr.replace('9', '1001')
arr = arr.replace('A', '1010')
arr = arr.replace('B', '1011')
arr = arr.replace('C', '1100')
arr = arr.replace('D', '1101')
arr = arr.replace('E', '1110')
arr = arr.replace('F', '1111')

patt = ['001101', '010011', '111011', '110001',
        '100011', '110111', '001011', '111101',
        '011001', '101111']

for i in range(len(arr) - 6):
    if arr[i: i + 6] in patt:
        x = patt.index(arr[i: i + 6])
        break

print(arr)
for i in range(arr.index(patt[x]), len(arr) - 6, 6):
    print(patt.index(arr[i: i + 6]), end =' ')
```



---

# Solving Club - 단순 2진 암호코드

어떤 국가에서는 자국 내 방송국에서 스파이가 활동하는 사실을 알아냈다. 스파이는 영상물에 암호 코드를 삽입하여 송출하고 있었다. 암호 코드는 국가 내 중요 시설을 의미하는 숫자임을 알아냈다. 암호 코드의 규칙은 아래와 같다.

1. 총 8개의 숫자로 이루어져 있다.
2. 앞 7자리는 상품 고유의 번호를 나타내며, 마지막 자리는 검증 코드를 나타낸다.
    - 검증코드는 아래와 같은 방법으로 계산한다.
      “(홀수 자리의 합 x 3) + 짝수 자리의 합 + 검증 코드” 가 10의 배수가 되어야 한다.
      상품 고유의 번호가 8801234일 경우,
      “( ( 8 + 0 + 2 + 4 ) x 3 ) + ( 8 + 1 + 3 ) + 검증 코드”
      = “42 + 12 + 검증 코드”
      = “54 + 검증 코드” 가 10 의 배수가 되어야 하므로, 검증코드는 6이 되어야 한다.
      즉, 88012346 이 정상적인 암호코드고, 그 외의 검증코드가 포함된 경우 비정상적인 암호코드다.

A 업체에서는 이 암호코드들을 빠르고 정확하게 인식할 수 있는 스캐너를 개발하려고 한다. 스캐너의 성능은 아래와 같은 방법으로 측정된다.

1. 세로 50. 가로 100 이하의 크기를 가진 직사각형 배열에 암호코드 정보가 포함되어 전달된다. 이 때, 하나의 배열에는 1개의 암호코드가 존재한다. (단, 모든 암호코드가 정상적인 암호코드임을 보장할 수 없다. 비정상적인 암호코드가 포함될 수 있다.)
2. 배열은 1, 0으로 이루어져 있으며 그 안에 포함되어 있는 암호코드 정보를 확인한다.
3. 포함된 암호코드들의 검증코드를 확인하여 정상적인 암호코드인지 확인한다.
4. 정상적인 암호코드들을 판별한 뒤 이 암호코드들에 적혀있는 숫자들의 합을 출력한다.
5. 이때, 총 소요시간이 적을수록 성능이 좋은 것으로 간주된다.



배열에 포함되어 있는 암호코드의 세부 규칙은 아래와 같다.

1. 암호코드 하나는 숫자 8개로 구성되며 시작 구분선, 종료 구분선은 별도로 존재하지 않는다.
2. 암호코드가 일부만 표시된 경우는 없다. 모든 암호코드는 8개의 숫자로 구성되어 있다.
3. 암호코드의 세로 길이는 5 ~ 50 칸이다.
4. 암호코드의 가로 길이는 총 길이는 56칸이다. 암호코드에 구성하는 숫자 하나가 차지하는 길이는 7칸이다. 각 숫자들을 그림으로 표시하는 방법은 다음과 같다.

* 0001101 - 0
* 0011001 - 1
* 0010011 - 2
* 0111101 - 3
* 0100011 - 4
* 0110001 - 5
* 0101111 - 6
* 0111011 - 7
* 0110111 - 8
* 0001011 - 9

암호코드 정보가 포함된 2차원 배열을 입력으로 받아 정상적인 암호코드를 판별하는 프로그램을 작성하라.



**[입력]**

가장 첫줄은 전체 테스트 케이스의 수이다.

각 테스트 케이스의 첫 줄에 두 자연수가 주어지는데 각각 배열의 세로 크기 N, 배열의 가로크기 M이다 (1≤N<50, 1≤M<100).

그 다음 N개의 줄에는 M개의 배열의 값이 주어진다.

**[출력]**

각 테스트 케이스의 답을 순서대로 표준출력으로 출력하며, 각 케이스마다 줄의 시작에 “#C”를 출력하여야 한다.

이때 C는 케이스의 번호이다. 같은 줄에 빈칸을 하나 두고, 입력에 주어진 배열에서 정상적인 암호코드들에 포함된 숫자들의 합을 출력한다. 





**나의 1안** [ 51,732kb, 155ms, 1,061 ]

뒤에서부터 1을 찾은 뒤, 55칸을 앞으로 가서 코드를 읽기 해석한다.

문제에서 말한 홀수번째 숫자와, 인덱스 입장에서 홀수번째 숫자는 다르므로 주의.

```python
import sys

sys.stdin = open('code_input.txt')

# 암호 코드 대조할 딕셔너리
secret_code = {
    '0001101': 0,
    '0011001': 1,
    '0010011': 2,
    '0111101': 3,
    '0100011': 4,
    '0110001': 5,
    '0101111': 6,
    '0111011': 7,
    '0110111': 8,
    '0001011': 9
}

# 해석 시작
def decode(code_r, c):
    # 홀수, 짝수 별로 누적시킨다.
    odd_num = 0
    eve_num = 0
    
    # 숫자는 총 8개, 반복문 8번
    for t in range(8):
        # 글자 7개 단위로 쪼갬
        arr = code_r[c+7*t:c+7+7*t]
        num = secret_code[arr]
        # 문제와 인덱스가 가리키는 홀 짝은 반대다
        if t % 2 == 0:
            odd_num += num
        else:
            eve_num += num
    
    if (odd_num*3 + eve_num) % 10 == 0:
        return odd_num + eve_num
    else:
        return 0

testcase = int(input())

for tc in range(1, testcase + 1):
    N, M = map(int, input().split())
    codes = [input() for x in range(N)]
    
    ans = -1
    for r in range(N):
        for c in range(M-1, 54, -1):
            # 뒤에서부터 읽어서 1 찾기
            if codes[r][c] == '1':
                ans = decode(codes[r], c-55)
                break
        if ans != -1:
            break
    
    print("#{} {}".format(tc, ans))
```





