> # 2019.03.14

# 잡설







# 컴퓨팅 사고력 workshop 리뷰

1 - 12번 **이혜희**

대우를 이용해서 증명

n = 3k+1 일 때, n^2은 3(3k^2 + 2k) + 1

n = 3k+2 일 때, n^2은 3(3k^2 + 4k + 1) + 1

즉 대우인 n이 3의 배수가 아니라면 n^2도 3의 배수가 아니다가 참이다.

따라서 명제도 참.



2 - 4 **우상원**

x = loga_yz

공식을 이용해서 x = (log_2 y + log_2 z) / log_2 a



3 - 16 **강민수**

카드 숫자가 A ~ K 13가지가 있다. 문양은 4가지 있다.

숫자 13가지 중 5가지 조합을 만들면 13C5

각 카드는 4가지 무늬 모두 가질 수 있으므로 x 4 5중첩.

따라서 13C5 x 4^5



3 - 16 **김규민**

카드 5개가 가질 수 있는 각각의 경우의 수를 곱한다.

뽑는 경우의 수 자체는 52 x 48 x 44 x 40 x 36

하지만 순서를 고려하지 말아야 하므로 5! 을 나눠야 한다.



---

# 컴퓨팅 사고력 2

## 4. 기초 수식

### 약간의 설명

시간 복잡도를 예측하기 위해 수식을 활용한다. (혹은 표현하거나)

풀이법을 익히면 코드를 보고 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있다.



### 연습문제들 : 재귀식들을 O() notation 수준으로 풀기

* 문제 1 : T(n) = T(n-1) + 1

  T(n) = T(n-1) + 1 = T(n-2) + 1 + 1 = ... = T(1) + 1 + ... + 1

  T(n) = O(n)



* 문제 2 : T(n) = T(n-1) + n

  T(n) = T(n-1) + n = T(n-2) + n-1 + n = T(n-3) + n-2 + n-1 + n = ... = T(1) + n + n-1 + ... + 2

  T(n) = O(n^2)



* 문제 3 : T(n) = T(n-1) + log n

  T(n) = T(1) + log n + log (n-1) + ... + log 2 <= T(1) + log n + log n + ... + log n

  <= T(1) + n log n

  T(n) = O(n log n)







---

## 5. 재귀

### 약간의 설명

* 재귀란 자기 자신을 호출하는 함수
* 자기 자신의 입력과 다른 입력을 넣어야 무한루프에 빠지지 않음
* 재귀는 base case와 inductive case로 나뉨
* 함수란 어떤 문제를 해결하는 방법을 코딩한 것
* 수학적 귀납법 증명을 통해 모든 n에 대해 문제를 풀 수 있다는 것을 알아낼 수 있음



### 연습 문제들: 재귀 알고리즘을 수도코드로 작성, 정확성 증명 및 시간 복잡도 계산을 수행하라

* 문제 1 : 피보나치 수열 : F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

  ```python
  fibo(n):
      if n <= 2:
          return 1
      return fibo(n-1) + fibo(n-2)
  ```

  Proof)

  **가정 : fibo(n)을 호출하면 F(n)이 return 됨을 알 수 있다.**

  1. n = 1, n = 2 일 때,

     fibo(1) = 1, fibo(2) = 1, 위의 코드가 성립

  2. n = k 일 때,

     fibo(1) ... fibo(2)이 F(1) ... F(k-1) 과 같다고 가정하자. 이때 F(k) = F(k-1) + F(k-2) 이므로, fibo(k) = fibo(k-1) + fibo(k-2) = F(k) 가 성립된다. 따라서 fibo(n)을 호출하면 F(n) 이 return 됨을 알 수 있다.

  **Time Complexity**

  T(n) = T(n-1) + T(n-2) + 1 < 2T(n-1) + 1

  T(n) = O(2^n)





* 문제 2 : Merge Sort, 크기 n인 배열을 입력받아, 배열을 절반으로 나눈 후, 각 작은 배열을 재귀적으로 정렬하고 그 결과를 Merge 한다.

  f(n) ==> L = f(n/2), R = f(n/2) ==> L + R





* 문제 3 : 다음 소팅 알고리즘이 실제로 소팅에 항상 성공한다는 것을 증명하라.

  ```python
  Stupid(A[0 ... n-1]):
      if len(A) == 2 and A[0] > A[1]:
          A[0], A[1] = A[1], A[0]
      else:
          m = 2n//3
          if 2n % 3 != 0:
              m += 1
          Stupid(A[0:m])
          Stupid(A[n-m:n])
          Stupid(A[0:m])
  ```

  수학적 귀납적 증명

  1. n = 2 일때,

     A[0] > A[1] 이라면 둘의 자리를 바꾼다. 위의 코드가 성립.

  2. n = k 일때,

     길이 k인 A[k]가 소팅 된다고 가정하자. 이 때, A[k+1]을 추가 하면 





* 문제 4 : 위의 소팅 알고리즘에서 수행하는 Swap의 횟수는 최대 몇번인가?





* 문제 5 : 어떤 배열 A[1 ... n] 에 (음수 포함) 정수 값이 증가하는 순서로 저장되어 있다. A[i] = i 가 되는 인덱스 i가 존재하는지...

  이진 검색을 활용

  가운데 인덱스와 비교하여 인덱스와 값이 일치하는지 확인한 수 너무 크면 더 큰 값으로 탐색, 반대라면 왼쪽으로 탐색





* 문제 6 : 루트 있는 트리를 입력으로 받아 아래와 같이 출력하는 알고리즘을 작성하라. 트리의 각 노드에는 1,000 미만의 자연수가 저장되어 있다. 트리의 노드 연결 관계는 다음과 같이 표현해야 한다. 아래 출력에서 루트에는 자식이 3개 있고 그 자식들 중 하나는 더이상 자식이 없는 것임을 알 수 있을 것이다.





---

## 6. 동적 프로그래밍

### 약간의 설명

* 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때, 그 결과 값을 저장해 두고 불러 쓰는 것이다. (Memoization)
* 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.
* 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수도 있다. (Dynamic Programming)

저 정도로 디테일하게 할 수 있으면 이미 pro 수준이다.







### 연습문제: 다음 문제들을 푸는 동적 프로그래밍 알고리즘을 수도코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행하라



* 문제 1 : Memoization 피보나치 수열

  F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

  (힌트 : 계산되는 값이 n 가지 밖에 없으므로 이 값들을 저장할 수 있는 배열을 만들어 두고 재귀 호출에 들어가기 전에 값이 있는지 확인하는 방법)

  ```python
  Fibonacci(n)
  {
      if n == 0 or n == 1:
          return 1
      if memoization[n] != none:
          return memoization[n]
      
      memoization[n] = Fibonacci(n-1) + Fibonacci(n-2)
      
      return memoization[n]
  }
  ```



* 문제 2 : Dynamic Programming 피보나치 수열 : F(n) = F(n-1) + F(n-2)

  (힌트 : 작은 값부터 순서대로 계산한다)

  ```python
  fibonacci(n)
  {
      f[0] = 0
      f[1] = 1
      for i in range(2, n+1):
          f[i] = f[i-1] + f[i-2]
      return f[n]
  }
  ```

이게 DP



**질문** : 실행시키면, 점화식, 메모이제이션, 다이나믹 중 어느 것이 가장 빠를까?

다이나믹이 가장 빠를 것이라 예상되며, 그 이유는 재귀 함수의 호출 시간, 재귀 함수의 호출 횟수 등에서 차이가 날 것이기 때문이다.

하지만 무조건 재귀보다 다이나믹이 빠르다고 단정지을 순 없다.



**<잡설>**

이러한 코드 스타일은 2가지로 탑 다운, 바텀업 방식이 있다.

둘 다 자유 자재로 쓸 줄 알면 상황에 알맞는 방식으로 더 쉽고 효율적인 코딩이 가능하다.





* 문제 3 : 행렬 곱하기, n개의 행렬을 곱하려고 한다. 크기가 a x b인 행렬과 크기가 b x c인 행렬을 곱하는데 드는 계산량은 a x b x c 라고 한다. n개의 행렬들을 곱하는데 필요한 계산량을 최소화 하는 순서를 찾는 알고리즘을 작성하라. 행렬들의 크기는 다르고, 입력으로 주어진다고 가정하라. 물론 행렬곱이 가능한 크기들만 주어진다.





## 과제

4 - 8

5 - 3,4

6 - 3







