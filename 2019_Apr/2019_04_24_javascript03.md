> # 2019.04.24

[TOC]

# 잡설

나 동영형이 보내준 그룹에 가입함.

c++

김선재 강사님이 오전 강동주 강사님이 오후



---

# AJAX

## 1. ajax 란?

Asynchronous Javascript and XML

어떠~~~ 인 것을 데이터를 바꿔주는 것.



네이버 들어가면 실시간 검색어가 특정 시간마다 한 번씩 갱신 된다.

이런걸 해주는게 ajax라고 한다.



~ 기능을 하는게 2가지 XMLHttpRequest, fetch

XHR는 모든 브라우저에 있는 빌트인 함수. 모든 브라우저라는게 핵심. 노드에서 사용할 수 없다는 뜻이다. 

이 객체를 통해 ajax 요청을 보낼 수 있게 된다. 



fetch는 설명 아직 안함



AJAX (Asynchronous Javascript and XML)

XHR(XMLHttpRequest) => 모든 브라우저에 built in 되어있는 객체

fetch => ES6 이후로 나온 ajax 함수



django와 다르게 JS 는 html 전체를  새로가져오지 않고 json으로 일부만 가져오고 조작.

그런 일련과정을 ajax라고 부른다.



---

## 2. ajax 출력해보기

**ajax.js** 파일 생성



**XMLHttpRequset() 함수**

new 라는 것은 어떤 클래스로 객체를 잡아놓고 new라는 것을 키워드로 인스턴스로 만드는 건데, 자세한 설명은 나중으로 미룰것이다.

JS 에서 ajax 요청을 보내는 객체. xml 뿐만 아니라 여러가지 json 등도 총괄.

```javascript
const XHR = new XMLHttpRequest()
```



특정 url에 요청을 보내기 위해, URL 설정 

<https://www.koreanjson.com/>

```javascript
const URL = 'https://www.koreanjson.com/posts/1'
```

홈페이지 밑에 있는 예제 코드를 콘솔에 실행해보자

```javascript
fetch('https://koreanjson.com/posts/1')
  .then(response => response.json())
  .then(json => console.log(json))
  .catch(error => console.log(error));

{id: 1, title: "정당의 목적이나 활동이 민주적 기본질서에 위배될 때에는 정부는 헌법재판소에 그 해산을 제소할 수 있고, 정당은 헌법재판소의 심판에 의하여 해산된다.", content: "모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다. 모든 국민은…진다. 누구든지 체포 또는 구속을 당한 때에는 즉시 변호인의 조력을 받을 권리를 가진다.", createdAt: "2019-02-24T16:17:47.000Z", updatedAt: "2019-02-24T16:17:47.000Z", …}
```





장고에서 요청하면 페이지를 보여주는데, 선생님 url은 페이지가 아니라 json타입의 데이터를 보내주는 api 서버.

그래서 여기서 보내주는 json 응답을 받아 볼 것이다.



어쨋든 open 할건데 우린 get 요청할 것이다. open으로 이 url을 통해 요청을 보낼거라는 준비, 열어주는 것.

send가 준비된 요청을 보내는 것.

get요청이라 우리가 data를 보낼 순 없고, 받기만 할거다.

```javascript
XHR.open('GET', URL)
XHR.send()  // 우리가 data 보낼 때
```



이벤트리스너 추가. 요청이 끝나면 함수 작동하게.

버전 6부터 나온 에로우 함수. 

```javascript
XHR.addEventListener('load', (evnt) => {  // 요청이 끝났을 때
    console.log(event)
})
```





컨트롤 쉬프트 i 누르면 콘솔창 열린다. j 말고도 i도 열린다.

```javascript
// 내 에러 표시. 하지만 수업에 지장은 엇다.
Access to XMLHttpRequest at 'https://play.google.com/log?format=json&hasfast=true&authuser=0' from origin 'chrome-search://local-ntp' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: The 'Access-Control-Allow-Origin' header has a value 'http://play.google.com' that is not equal to the supplied origin.
```



나는 콘솔창만 열었을 땐 에러문구가 나와서 구글 시크릿 모드를 켜서 해봤음.

근데 devtool 이 리로드 안된다고 에러.



그래서 그냥 콘솔에 코드 실행

```javascript
XHR.addEventListener('load', (evnt) => {  // 요청이 끝났을 때
    console.log(event)
})

ProgressEvent {isTrusted: true, lengthComputable: true, loaded: 771, total: 771, type: "load", …}
```



접힌걸 폈는데 정말 많은게 들었음. 하나만 더 디테일하게 뽑아보자.

```javascript
const XHR = new XMLHttpRequest()
const URL = 'https://www.koreanjson.com/posts/1'

XHR.open('GET', URL)
XHR.send()

XHR.addEventListener('load', (evnt) => {  // 요청이 끝났을 때
    console.log(event.target.response)
})

{"id":1,"title":"정당의 목적이나 활동이 민주적 기본질서에 위배될 때에는 정부는 헌법재판소에 그 해산을 제소할 수 있고, 정당은 헌법재판소의 심판에 의하여 해산된다.","content":"모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다. 모든 국민은 종교의 자유를 가진다. 국가는 농·어민과 중소기업의 자조조직을 육성하여야 하며, 그 자율적 활동과 발전을 보장한다. 모든 국민은 양심의 자유를 가진다. 누구든지 체포 또는 구속을 당한 때에는 즉시 변호인의 조력을 받을 권리를 가진다.","createdAt":"2019-02-24T16:17:47.000Z","updatedAt":"2019-02-24T16:17:47.000Z","UserId":1}
```





string인데 ...

아놔 한참 못 씀.

js 에서는 json, python에서는 dictionary



json을 파싱하는 작업 필요.

JSON이라는 객체... 정확하겐 인터페이스가 있다. 메소드2가지 존재. 

```javascript
const XHR = new XMLHttpRequest()
const URL = 'https://www.koreanjson.com/posts/1'

XHR.open('GET', URL)
XHR.send()

XHR.addEventListener('load', (evnt) => {  // 요청이 끝났을 때
    const rawData = event.target.response
    const parsedData = JSON.parse(rawData)  // String => Object
    console.log(parsedData)
})

// 아래는 응답인데 오브젝트 형식으로 바뀜. 이거 긴데, 현재 이것도 접힌 상태
{id: 1, title: "정당의 목적이나 활동이 민주적 기본질서에 위배될 때에는 정부는 헌법재판소에 그 해산을 제소할 수 있고, 정당은 헌법재판소의 심판에 의하여 해산된다.", content: "모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다. 모든 국민은…진다. 누구든지 체포 또는 구속을 당한 때에는 즉시 변호인의 조력을 받을 권리를 가진다.", createdAt: "2019-02-24T16:17:47.000Z", updatedAt: "2019-02-24T16:17:47.000Z", …}
UserId: 1
content: "모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다. 모든 국민은 종교의 자유를 가진다. 국가는 농·어민과 중소기업의 자조조직을 육성하여야 하며, 그 자율적 활동과 발전을 보장한다. 모든 국민은 양심의 자유를 가진다. 누구든지 체포 또는 구속을 당한 때에는 즉시 변호인의 조력을 받을 권리를 가진다."
createdAt: "2019-02-24T16:17:47.000Z"
id: 1
title: "정당의 목적이나 활동이 민주적 기본질서에 위배될 때에는 정부는 헌법재판소에 그 해산을 제소할 수 있고, 정당은 헌법재판소의 심판에 의하여 해산된다."
updatedAt: "2019-02-24T16:17:47.000Z"
__proto__: Object
```



아래와 같이 써보자. 구글 페이지가 새로고침 되면서 응답을 띄운다.

```javascript
const XHR = new XMLHttpRequest()
const URL = 'https://www.koreanjson.com/posts/1'

XHR.open('GET', URL)
XHR.send()

XHR.addEventListener('load', (evnt) => {  // 요청이 끝났을 때
    const rawData = event.target.response
    const parsedData = JSON.parse(rawData)  // String => Object
    document.write(parsedData.content)
})

모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다. 모든 국민은 종교의 자유를 가진다. 국가는 농·어민과 중소기업의 자조조직을 육성하여야 하며, 그 자율적 활동과 발전을 보장한다. 모든 국민은 양심의 자유를 가진다. 누구든지 체포 또는 구속을 당한 때에는 즉시 변호인의 조력을 받을 권리를 가진다.
```

근데 의문

구글 검색 엔진이 있던 페이지가 싸그리 날아가고, 아래 글이 출력

하지만 항상 덮어 씌우는게 아닌데

페이지가 완전히 로드 된 이후에 write하면 덮어씌우고

아니면 append 처럼 추가





---

## 3. Giphy - html, css 구현

새 폴더 giphy-search-engine

전생 앱과 비슷

그냥 link + tab 누르면 자동완성



**index.html**

`div.container.container-padding50 + [tab]`



`input.container-textinput + [tab]`

id, value 추가



`button.container-button + [tab]`

id, 가운에 문구 추가



`div.container.container-padding50.js-container`

id추가



main.js 생성하여, html에 `<script>` 태그 추가.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Giphy Search Engine</title>
    <link rel="stylesheet" href="./main.css">
</head>
<body>
    <div class="container container-padding50">
        <input id="js-userinput" type="text" class="container-textinput" value="HPHK">
        <button id="js-go" class="container-button">Go!</button>
    </div>
    <div id="result-area" class="container container-padding50 js-container">
    </div>

    <script src="./main.js"></script>
</body>
</html>
```



**main.css**

css 내용은 slack에 공유된 것을 복붙.

```css
body {
    width: 80%;
    max-width: 1024px;
    margin: 0 auto;
    background-color: black;
}

h1 {
    color: white;
}

.img-center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container-padding50 {
    padding-top: 50px;
}

.container-textinput {
    width: 80%;
    display: inline-block;
    padding: 20px;
    font-size: 16px;
    font-family: Helvetica, sans-serif;
}

.container-button {
    width: 10%;
    display: inline-block;
    padding: 20px;
    background-color: green;
    color: white;
    font-size: 16px;
    font-family: Helvetica, sans-serif;
    border: 1px solid green;
    border-radius: 5px;
}

.container-image {
    width: 30%;
    display: block;
    float: left;
    margin-right: 3%;
    margin-bottom: 5%
}
```



html 파일을 브라우저 창에 드래그 해서 띄울 수 있다.

그러면 까만 배경에, 검색엔진, 초록색 버튼이 볼 수 있다.



---

## 4. Giphy - JS 구현

main.js에서 할일은 크게 3가지

1. input 태그 안의 값을 잡는다.
2. Giphy API를 통해 data를 받아서 가공한다.
3. gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.

```javascript
// 1. input 태그 안의 값을 잡는다.

// 2. Giphy API를 통해 data를 받아서 가공한다.

// 3. gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.
```



### -1 input 태그 안의 값을 잡는다.

**main.js - 1번 영역**

```javascript
const input = document.querySelector('#js-userinput');
const value = input.value;
console.log(value)
```

이러고 새로고침 하면, 콘솔창에 HPHK이 출력.

하지만 버튼 눌러도 반응 없다.



그러니 버튼을 눌르면 반응하도록 이벤트 추가.

```javascript
const button = document.querySelector('#js-go')
const input = document.querySelector('#js-userinput')

button.addEventListener('click', (e) => {
    const value = input.value
    console.log(`click : ${value}`)
})
```

이러면 클릭하면 콘솔창에 HPHK이 출력.



키보드를 눌러도 반응하게 끔 살작 테스트 해보자.

```javascript
input.addEventListener('keypress', (e) => {
    console.log(e)
})
```

이러면 input 창에 알파벳 (한글 x) 누를때마다 어떤 event인지 자세히 출력된다.



Enter 키의 코드가 13임을 이용하여, Enter 일 때만 출력하게 해보자.

```javascript
input.addEventListener('keypress', (e) => {
    if (e.keyCode === 13) {
        const value = input.value
        console.log(`enter : ${value}`)
    }
})
```

이러면 엔터 누를때만 input의 value값이 콘솔창에 출력.



### -3 gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.

**main.js - 3번 영역**

resultArea에 html을 집어넣을거면 `innerHTML` 을 사용해야 한다.

```javascript
const pushToDom = (data) => {
    resultArea.innerHTML = data
}
```



html 파일에서 가져와야 할 것을 맨 위에 변수로 저장한다.

그리고 버튼을 누르거나 Enter를 누르면, input 창 아래에 까만 글씨가 출력되게 해놓았다. 까만 배경에 까만 글씨라서 드레그를 해야 비로소 보인다.

```javascript
// 1. input 태그 안의 값을 잡는다.
const button = document.querySelector('#js-go')
const input = document.querySelector('#js-userinput')
const resultArea = document.querySelector('#result-area')

button.addEventListener('click', (e) => {
    const value = input.value
    pushToDom(value)
})

input.addEventListener('keypress', (e) => {
    if (e.keyCode === 13) {
        const value = input.value
        pushToDom(value)
    }
})

// 2. Giphy API를 통해 data를 받아서 가공한다.
// https://developers.giphy.com/


// 3. gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.
const pushToDom = (data) => {
    resultArea.innerHTML = data
}
```



### -2 Giphy API를 통해 data를 받아서 가공한다.

이제 Giphy에서 제공하는 API를 사용.

내 계정 다시 확인 - 구글 메일 / 최장형

<https://developers.giphy.com/docs/>



**main.js - 2번 영역**

api키 받아서 변수로 저장하고, 요청할 url 을 저장한다.

```javascript
const API_KEY = 'BAI4AEuap7G1HTwi24SbARTWpwAWu7wr'
let keyword = 'matrix'
const URL = `http://api.giphy.com/v1/gifs/search?q=${keyword}&api_key=${API_KEY}`
```



요청한 응답이 들어온거 출력하기.

파싱하기 전 data를 콘솔에 출력하면 매우 긴 것이 나왔으나,

파싱한 data는 많이 줄어서 들어왔다.

```javascript
const GiphyXHR = new XMLHttpRequest()
GiphyXHR.open('GET', URL)
GiphyXHR.send()

GiphyXHR.addEventListener('load', (e) => {
    const rawData = e.target.response
    const parsedData = JSON.parse(rawData)
    // console.log(rawData)  // 뭔가 엄청난게 긴게 왔음
    // console.log(parsedData) // 25개 정도 들어옴
})
```



---

**질문 - 함수 선언**

참고로 아래 2개는 여전히 익명함수다.

```javascript
function sum1 (a, b) {
    return a + b
}

const sum2 = function (a, b) {
    return a + b
}

const sum3 = (a, b) {
    return a + b
}
```

우리는 왠만해선 함수를 변수에 담아서 활용할 것이다.

function, arrow로 선언한 함수는 미세한 차이가 있다.

JS는 this라는 키워드가 있다.

```javascript
const sum2 = function (a, b) {
    this // 실행하는 시점의 객체
    return a + b
}

const sum3 = (a, b) {
    this // 선언하는 시점의 객체
    return a + b
}
```

객체란 함수가 될 수도 있고, object가 될 수도 있다.



**강선진 질문은 내일 자세히 다룰 예정**



질문 - const url에 대해

const URL은 선언된 시점에서 keyword와 api_key를 받아와서 인터폴레이션을 스트링으로 바꿔버린다.

그래서 keyword와 api_key를 반드시 먼저 선언되어야 한다.

나중에 동적으로 변할 수 있도록 설계하는 법을 나중에 배울 것이다.



---

## 5. Gif 파일 가져오기

json을 뜯어 볼 것이다.

fixed height가 이미지가 이쁠 확률이 크므로 그것의 url 선택.



---

## 6. 검색어 관련 gif 가져오기

현재 만들어진 상태로는 URL이 const로 굳어져서 다른 검색어가 들어갔을 때, 동적으로 바꿔가면서 사용할 수 없다.

함수 안에 const url을 그때 그때 선언해서 재활용한다. const는 스코프가 블록 단위라서 충돌 날 일이 없다.



`Ctrl +  D` 중복 선택. 특정 같은 단어들을 한꺼번에 바꿀 수 있다.



**main.js**

`searchAndPush` 함수에 옮겨 담기.

1, 2, 3번 영역에 존재하는 코드 다 손본다.

```javascript
// 1. input 태그 안의 값을 잡는다.
const button = document.querySelector('#js-go')
const input = document.querySelector('#js-userinput')
const resultArea = document.querySelector('#result-area')

button.addEventListener('click', (e) => {
    const value = input.value
    searchAndPush(value)
})

input.addEventListener('keypress', (e) => {
    if (e.keyCode === 13) {
        const value = input.value
        searchAndPush(value)
    }
})

// 2. Giphy API를 통해 data를 받아서 가공한다.
// https://developers.giphy.com/
const searchAndPush = (keyword) => {
    const API_KEY = 'BAI4AEuap7G1HTwi24SbARTWpwAWu7wr'

    // template literal
    const URL = `http://api.giphy.com/v1/gifs/search?q=${keyword}&api_key=${API_KEY}`

    const GiphyXHR = new XMLHttpRequest()
    GiphyXHR.open('GET', URL)
    GiphyXHR.send()

    GiphyXHR.addEventListener('load', (e) => {
        const rawData = e.target.response
        const parsedData = JSON.parse(rawData)
        for (data of parsedData.data){
            pushToDom(data.images.fixed_height.url)
        }
    })
}

// 3. gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.
const pushToDom = (data) => {
    resultArea.innerHTML += `<img src="${data}"/>`
}
```



근데 이상태로는 검색 결과가 누적된다. cat 검색 후, dog 검색하면 쌓여있다.

`resultArea.innerHTML = null` 를 맨 위에 추가해서 항상 초기화 한다.

```javascript
const searchAndPush = (keyword) => {
    resultArea.innerHTML = null
    const API_KEY = 'BAI4AEuap7G1HTwi24SbARTWpwAWu7wr'
    ...
        }
    })
}
```



**이미지 출력방식 바꾸기 - 3번 영역**

아까는 `innerHTML +=` 방식으로 뽑아온 url을 누적시켰다. 하지만 이 방식은 resultArea 전체를 지웠다가 쌓고 다시 출력하는 방식이라 시간이 오래 걸린다.

`appendChild()` 를 사용하면 추가만 시키므로 상대적으로 더 빠르다.

눈으론 차등 없어보이나 그건 기분탓...

```javascript
// 3. gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.
const pushToDom = (data) => {
    const img = document.createElement('img') // <img></img>
    img.setAttribute('src', data) // <img src="${data}" />
    resultArea.appendChild(img)
}
```



**이미지 출력시 속성 부여하기**

어트리뷰트를 추가로 부여해준다. 이미지에 여백이 생긴다.

```javascript
// 3. gif 파일들을 index.html(DOM)에 밀어 넣어서 보여준다.
const pushToDom = (data) => {
    const img = document.createElement('img') // <img></img>
    img.setAttribute('src', data) // <img src="${data}" />
    img.className = 'container-image' // === setAttribute('class')
    resultArea.appendChild(img)
}
```



**innerHTML, appendChild() 동작방식**

원본이 아래와 같다고 하자.

```html
<div id="resultArea">
    <ul>
        <li></li>
        <li></li>
    </ul>
</div>
```

그리고 `<img>` 태그를 추가하면 아래와 같다. `<div>` 기준으로 마지마에 배치.

```html
<div id="resultArea">
    <ul>
        <li></li>
        <li></li>
    </ul>
	<img>
</div>
```



---

# REST API

## 0. REST API 이란?

공유 드라이브에 새 슬라이드 업로드



요청하고 응답받고 조작하고 어디에 또 올리고

서버를 구축하는데, 데이터를 받는 서버를 어떻게 구축하는게 이번 주제



API 쓰다보면 REST API 도구를 많이 보게 될 것이다.



아~주 오래전 영화진응위원회 API 쓴 적이 있을 것이다.



~~가 카카오 공채에 나온다.

내가 마음데로 사용하되, REST API, JSON Parser 는 무조건 필요하다고 공채 정보에 올라옴.

우린 JSON Parser를 이미 2번이나 했다. python에서 string을 dictionary로 바꿀 때, JS에서 string을 object로 바꾼게 그것.

요즘은 외부 라이브러리도 마음껏 쓰는게 트렌드. 

또 REST API는 전공 면접에도 자주 언급.



xml이 데이터 주고 받고 많이 썼는데, 나중에 보니 개극혐.

안드로이드 프로그램은 뷰를 xml로 구성해야해서 꼭 배워야한다.

그런데 yaml이 등장. 얘뮬. 얜 마크업 언어는 아니다. 얘 이름 자체가 재귀 식이라 나는 마크업 언어가 아니아~~~ 무한 반복

얘는 태그가 사라졌다. 이건 homeworkshop에서 본 적 있으니 참조.

json이랑 유사해짐. 언어를 yaml로 바꿔주는 변환을 많이 쓰다가... 이것 마저도 불편하다고 느껴졌다고 함.



JS에 어브젝트에 담아 쓴 것처럼. 뭘 하는데... 이걸 줄여서 표현한 것이 JSON 그래서 얘가 굉장히 핫 한 것이다.

`XMLHttpRequset` 라는 함수 이름도 결국 전통 때문에 이렇게 만들어진것.

핵심은 XML이 아니라 HttpRequest 가 핵심이다.





http?

HyperText Transfer Protocal



---

## 1. HTTP

경제성을 위해 어떤 것들이 만들어짐



인터넷에서 어떤 정보를 찾는다!

URL(Uniform Resource Identifier)

통합자 자원 식별자



그냥 만들다보니 만들어졌고, 이렇게 온거라 아직 정리되지 않는 부분이 있다.

그래서 앞 부분은 통일 된것처럼 보이지만... 

다른 사람의 url이 뭘 위한 것인지는 알아볼 수 없다.

개발자가 거기에 맞춰서 뭘 만들기도 나쁘다.

서로 데이터를 주고 받기가 너무 나쁘다.

어떤 법칙이 없다보니까 불편...



HTTP 요청 URL on Django



어떤 박사가 나와서 우리 url을 너무 개판으로 쓰니까 

RESTful



내가 어떤 사이트를 갈때 url의미를 모두 알아야 한다면 너무 hell

이걸 심플하게 만들어보자! 문서를 거의 보지 않더라도 알 수 있게 만들고 싶다.

공통규약을 만들기 시작했다. 



문제점은 url을 정보를 너무 마음데로 다룰 수 있기 때문이다. 동사적 의미를 넣는게 원흉인 것 같다. 앞으로 url에서 동사를 모두 빼는 건 어떨까? url 안에 집어넣지 말고 다른곳에 넣자



CRUD에 관한 동사는 모두 그곳에 있을 것이고, 각각의 상태를 어떻게 표현할텐가? 

Read는 GET이라는게 있잖아! ㅇ그러니 Read는 Get일 때만 쓰는건 어떨까?

POST는 create에만 쓰고, PUT은 update, DELETE는 Delete에 넣자.

전부 http 메소드로 표현하자!!!



GET이 

URL을 동사하다!!!



show, detail에서

posts/1/ 에서 1을 path variable이라고 부르기도 한다.



update는 어떤 타겟을 지정해야 하니까

posts/1/

근데 delete도?

posts/1/



URL은 2개지만 분할은 http 메소드로 해주니까 깔끔하면서도 엉키지 않는다.



RESTful 하다는 이야기가 결국 위 가은 것. url을 심플하게 짜기 위한 우리의 약속. 나머지는 그냥 수반된 것이다.



REST 중심 규칙

1. URI는 정보의 자원을 표현해야 한다.
2. 자원에 대한 행위는 HTTP Method로 표현한다.



그래프 QL인데 이건 시간 나면 알아서 알아보도록 해라. 

그래프 QL로 가게 되면 정말로 이상해진다.



---



korean json 가보았나?

메인 사이트에서 JSONPlaceholder로 들어가면 외국거 참조 가능

그리고 RESTful한 예시를 볼 수 있다.



POST ??라는게 뭘 도와줄ㄱ다

<https://www.getpostman.com/downloads/>

64비트로 받자.



URL 만드는 창 옆에 고르는거 보이나?

PUT, PATCH는 거의 동일하게 쓰이지만 우린 PUT을 사용



Body 만들고 raw - JSON

어? id는 알아서 써주남?

REST API를 쓰는 사람끼리는 url만 봐도 어떤 기능을 하는 페이지인지 예측 가능.







header와 data에 정보를 담아 얼굴 요청한게 기억하는가?



알게보르게 브라우저가 다신 우리보다 햊ㅇ썬 여구.



콘솔창 열고 네트워클 변경해본다.ㄴ트워크 치면 붐가...





...



...



GET/posts는 

* Headers

  부가 보내는지(User-Agent), 뭘 보내는지(파일형태) 어떤 언어로 보내는지 (언어 인코딩)

* Body

  데이터

이렇게 담아서 주소로 보내누는 것으로 보면 딘다.





오늘 필기 ㅈ망!!!!!!!!!!!!!!!!!!!!!!!!!!!



왜 이렇게 하는가...?

JS는 함수안에 함수를 쳐 집어넣는거에 의구심을 가져봐라.

JS의 동기성에 대해서 알거다



---

JS는 왜 이렇게 생겼는가?



dogjs.js 생성



강사님이 수업 30분 공략 걸으심. 타이머 만들어 보자!



**sleeptest.py 생성**



```python
from time import sleep

def finish():
    sleep(5)
    print("수업 종료되었습니다.")

print("수업중")
finish()
print("땡땡땡~!")
```



이걸 js로 해볼까?

js는 sleep대신 setTimeout을 쓰고, 단위는 초가 아니라 ms이다.

```javascript
// 30분 뒤에 종료를 알리는 js 코드

function finish() {
    setTimeout(10000, function() {})
    console.log("수업이 종료되었습니다.")
}

console.log("수업중")
finish()
console.log("땡땡땡~!")
```

근데 아무리 시간 늘려도 기다리지 않고 한 번에 출력한다.

console.log를 setTimeout 안에 넣었다. 그럼 되겠지? ㅎㅎ

```javascript
// 30분 뒤에 종료를 알리는 js 코드

function finish() {
    setTimeout(1, function() {
        console.log("수업이 종료되었습니다.")
    })
}
console.log("수업중")
finish()
console.log("땡땡땡~!")
/*
수업중
땡땡땡~!
*/
```

ㄴㄴ 수업이 종료되었다라는 메세지는 죽었다 깨어나도 안 뜬다.



일단 수업 종료 되었다는 얘기는 듣고 싶으니

```javascript
function finish() {
    setTimeout(function() {
        console.log("수업이 종료되었습니다.")
    }, 1000)
}

console.log("수업중")
finish()
console.log("땡땡땡~!")
/*
수업중
땡땡땡~!
수업이 종료되었습니다.
*/
```

순서데로 되지 않는다!!



우리가 짰던 모든 프로그램은 무조건 위에서 아래로 실행되도록 설계되어있다.

하지만 위에서 봤든 JS는 함수를 쌩까고 아래 console.log부터 실행.

이것은 JS의 non-blocking 특징이 있기 때문이다.

보통은 위의 명령이 실행되기 전에는 뒤에는 실행되지 않도록 막는다 (Blocking)

하지만 JS는 non-blocking이라 위의 명령이 실행되던 안되던 말지 않는다. 한 코드가 끝나기까지 기다리지 않는다. 다른 코드가 먼저 실행되는 것을 안 막는다.



새롭게 설계해보자.



`Date.now()` 는 우리가 보기 힘든 시각을 내뱉음. 1970년을 기준으로 지나버린 시간을 의미.

unix epoch time

컴퓨터는 1970년 1월 1일 00:00:00 기준으로 시작매김. 이건 세계 공통.

나라마다 다른 달력을 사용하기도 하니까 컴퓨터 만큼은 통일시키도록 하기 위해서임.



```javascript
// 30분 뒤에 종료를 알리는 js 코드
function sleep() {
    let start = Date.now()
    while (Date.now() < start + 5000) {}
}

function finish() {
    sleep()
    console.log("수업이 종료되었습니다.")
}

console.log("수업중")
finish()
console.log("땡땡땡~!")
/*
수업중
수업이 종료되었습니다.
땡땡땡~!
*/
```

왜 이런 차이가 있는가?

재밌는 실험 해보자



**index.html**

`<a>` 태그 추가



5초가 지나기 전까지 a 태그 출력 안됨.

다시 시작하면 a 태그가 보이긴 하지만 눌러도 반응 없다. 5초 풀리면 그제서야

뒤로가기 눌러도 5초 걸린다.



JS는 브라우저를 돌리기 위한 것이다.

싱글 스레드다. 실행되고 있는 컨텍스트가 1개 밖에 없어서. 이게 while 하나 돌리면 나머지를 아무것도 처리하지 못 한다. JS에서 실행되는 프로그램은 브라우저 하나라서 ...

그래서 setTimeout이 필요한 것이다. IO, 3테라짜리 파일 열어아한다면 브라우저는 그거 다 할 때까지 아무것도 못할 것이다. 이러면 브라우저 쓰는 의미가 없다.

막는코드와 막지 않는 코드가 따로 존재한다.





setTimeout을 만나면 멈추지 않고, JS는 이벤트 루프를 돌린다. 대기 명단과 같은 것이다.

일단 나머지를 처리하되, 대기 명단 끝날 때까지 기다려줌. 함수가 돌아가기 보단 조건만 체크해주는 느낌이다.

하지만 return은 당장 해준다.

구글에 js eventloop 검색해서 한번 보자. heap가 넣어주고 끝나면 callstack이 불러준다.



어쨋든 작업이 오래 걸리는 함수는 non-blocking 으로 만들어졌다.

어떤 함수가 끝나는 시점에 끝내고 싶으면... call stack이 자주 언급되는 이유.



JS 자체가 실제 싱글스레드가 아니다. 하지만 읽는 과정은 싱글스레드가 맞다. 다만 JS 실행되는 형태가 싱글 스레드가.

이렇게 더러움에도 불구하고, 멀티스레딩이 좋아서 뜬거. python으로 멀티스레드 해봐라 죽어난다. 어떤 리소스를 공유하도 되고, 안되고가 제각각. 원래라면 우리가 다 설계해줘야 한다.





옛날에는 cpu 1개였는데, 이제는 멀티코어. 싱글코어는 몇 개까지 다룰 수 있을까/

1개 일 때는 하나의 프로세스 뿐이다.



이런 개념을 매우 잘 표현한 수업 중 하나가

http://ops-class.org

여기 os 수업이 매우 정리가 잘 되어있다.

한글이 보고 싶다면 서울대에서 제공하는게 있다.



---

내일 할것

비동기적인 act 자세히

그걸 js가 컨트롤 하는 방법



