> # 2019.04.26

[TOC]

# 잡설

* import, 함수, 인자요소 검토

1. 회원가입

   * 커스텀 유저

     ```python
     import django.contrib.auth.models import AbstractUser
     import django.cotrib.auth.forms import UserCreationForm
     import django.conf import settings
     import django.contrib.auth import user_get_model
     
     # settings.py
     AUTH_USER_MODEL = 'accounts.User'
     ```

     ```python
     class User(AbstractUser):
         follower = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, related_name="followings")
     
     class CustomUserCreationForm(UserCreationForm):
         class Meta:
             model = user_get_model()
             fields = UserCreationForm.Meta.fields
     .all()
     posts = Post.objects.filter(user__in = request.user.followings.values('id')).order_by('-pk')
     # .values('id') 대신에 .all() 해도 돌아갔다.
     ```

     

* django `blank=True` vs `null=True`

blank=True 는 validation 단계에서 필한 것이고



---

# Javascript - view

## 1. JS OOP?

### JS로 OOP 구현하기

JS 도 클래스를 통해 객체를 만들 수 있다.

하지만 우리가 기존에 했던 것과 다른 느낌을 받을 것이니, 너무 기존의 지식으로 접근하려하지 말아라.



object oriented programming

세상을 사람이 인지하는 방식으로 프로그램에게 전달하기 위해서.

나무라는 객체에 속성과 행동으로 나눠 생각하여 이해한다.



Python에서와 JS 에서의 차이가 있다.

Python은 클래스를 만들어야 한다. 하지만 JS는 클래스 없이 객체 생성한다.

JS는 dictionary대신 object라고 불리는데, 얘가 객체처럼 행동한다.



**Python**

```python
class Person():
    def __init__(self, name):
        self.name = name

donghoon = Person('donghoon')
```



**JS**

```javascript
donghoon = {
    name: 'donghoon',
    poop() {
        console.log("끙")
    }
}
console.log(donghoon.name)
console.log(donghoon.poop())
```

bash에서 실행

```bash
$ node object.js
donghoon
끙
undefined
```



아래처럼 조정

```javascript
donghoon = {
    name: 'donghoon',
    poop() {
        return "poop"
    }
}

junse = {
    name: 'junse',
    poop() {
        return "poop"
    }
}

console.log(donghoon.name)
console.log(donghoon.poop())

console.log(junse.name)
console.log(junse.poop())
```

bash 창에서 실행.

```bash
$ node object.js
donghoon
poop
junse
poop
```



글자로 객체를 표현하는 literal 머시기

함수를 선언하는 방식이 다른 때와 다른데, 이는 아래 코드를 ES6부터 압축해서 사용하기 때문.

```javascript
poop: function () {
    return "poop"
}
```



만약에 아래 처럼 코드를 입력하면 function 자체가 나온다.

```javascript
console.log(junse.poop)
// [Function: poop]
```



### python처럼 쓸 수 있게된 JS OOP

예전엔 문자로 일일이 입력했는데 지금은 다른 언어처럼 클래스 선언 마냥 사용 가능.



**python class 선언**

```python
class Person:
    def __init__(self, name):
        self.name = name
    
    def poop(self):
        return "poop"
    
    def hello(self):
        return f"안녕 나는 {self.name}야"
```



**JS class 선언**

객체 스스로를 가리키는 것이 this. 물론 엄밀히 들어가면 스스로 지칭이 안 될 때가 있지만 넘어가자.

익명함수도 아니고 애로우 함수도 아니니 선언할 때 문법형태에 주의.

```javascript
class Person {
    constructor(name) {
        this.name = name
    }

    poop() {
        return "poop"
    }

    hello() {
        return `안녕 나는 ${this.name}야`
    }
}
```



**python class 객체 사용**

```python
donghoon = Person("동훈")
```



**JS class 객체 사용**

```javascript
const donghoon = new Person("동훈")
```



### naver

F12 누르고 Element 가면 eventListenr 등이 적혀있다.



콘솔에서 아래와 같이 어느 객체를 살펴보자

```javascript
// document.querySelector('a')

const start = document.querySelector('.al_favorite')
start.addEventListener
// 뭔가 엄청나게 많이 뜬다.

console.log(typeof(start))  // object
console.dir(start)  // 내부를 들여다 볼 수 있다. 어떤 property, method 가지고 있는지
/* __proto__: HTMLAnchorElement라는게 있다.
프로토타입의 약자
얘가 어떤 클래스로부터 왔는지 알 수 있다 정도로 생각해라
근데 __proto__ 가 또 있다.
HTMLElement, Element, Target, Object(마지막)
결국 뿌리는 object로 이루어졌다.
/*
```



### Python dict에 함수 넣기

Python도 dictionary에 함수를 넣는 것이 가능한가?

**dictfunk.py**

```python
donghoon = {
    "name": "donghoon",
    "poop": lambda : 'poop'
}
print(donghoon['poop']())
# poop


def poop():
    return "poop"

donghoon = {
    'name': 'donghoon',
    'poop': poop
}
print(donghoon['poop']())
# poop
```

