# 인트로

#### html 셀프조사

html은 문서의 특정 텍스트 영역이 문단인지 목록인지 표의 일부인지 구분할 수 있도록 의미를 부여하고, 헤더인지, 콘텐츠 컬럼인지, 네비게이션 메뉴인지 알 수 있도록 논리적인 영역으로 구조화 하고 이미지와 비디오 같은 콘텐츠를 삽입할 수 있게 해주는 요소들로 구성된 지극히 간단한 언어이다.



#### 백경원 강사님 (12주)

효과적인 강의에 관심이 많으셨던 분. APS기본 (이론, 실습) 과정을 만드셨나 봄.

삼성 SW 검정시험. 등급들: 검정 - im - adv - pro - ex

im 에서 adv 가는게 100배 힘들다면 pro로 가는 것은 10000배 힘들다.

expert 시험은 1 ~ 2명만 합격함(상대평가).

pro 문제 스타일은 짧은 시간에 구현을 잘해야 함.

adv하려면 

작년까지 삼성 전산 사내에서 pro 딴 사람이 25%

adv목표로 잡은 사람은 검색만 잘해도 충분하다.

# Advanced Road View

lang (-type, -제어, ...)

**im(inter media)과정**

구조적 프로그래밍에는 3가지 구조가 있다.

* 순차구조 (x=10; x=20; 하면 x=20이 적용)
* 선택구조 (if)
* 반복구조 (for)

내가 원하는 답을 구하는 과정을 잘 이끌어내기만 하면 된다.

보통 2차배열을 다루는 문제가 많이 나옴.

**adv** 는 여기서 focus를 더 좁힌 것(?)



코드를 짜다보니 효율적인 패턴이 있더라. 

**자료구조 측면**

* 자료구조 맥락
* * -자료구조(stack, top 등 저장했다가 필요할 때 쓰는 것)
  * -연산(삽입, 삭제)
* ADT(abstract data type)
* * 구현, 선택
* 선형자료구조 0 - 0 - 0 일렬로 구조
* * 배열 (삭제하면 삭제한 부분이 붕 뜸) (im 수준)
  * list (삭제하면 공백을 채워 놓음)
  * stack
  * queue
  * str
* 비선형자료구조 (adv 정도면 이걸 잘 다루고 즉석으로 표현이 가능해야 함.)
* * tree (1차 배열로 표현할 것이냐, 링크드 리스트로 표현할 것이냐)
  * graph
  * * MST
    * 최단경로 (다익스트라, 벨만포드, 플로이드워셔)
    * TSP 여행자 경로 문제 (NP class 문제, 인간 수명안에 연산 못 함)
  * * 인접 행렬
    * 인접 리스트

* 순회(traversal) (중복없이 모든 요소를 조사하는 방법. 특히 tree구조에서 어려움)
* * BFS (너비우선 탐색)
  * DFS (깊이 우선탐색, 일단 아무거나 탐색하고 더이상 탐색할 것이 없으면 회귀하고 다른 걸 찾음)
  * in order, pre order, post order 등을 선택할 줄 알아야 adv 될까말까.

여기 까지가 adv의 기본

이진tree, 이진탐색  tree, 트라이, segment tree, index tree, 패딕트리, 호프만 트리

이진 탐색: 작은 수를 왼쪽에 배치. 그런데 가끔 선형구조를 만들어 버릴 때가 있다.

이걸 재배열 한 것이 able tree.

tcg

* 네트워크간
* * AOE
  * AOV



**알고리즘 적인 측면**

* 그리드 (탐욕 알고리즘 설계 기법)
* 분할정복 (저장공간을 쪼개고 하나를 탐색하고 하나를 버린다고 보자.)
* 백트래킹(상태공간트리 + DFS, 가지치기)
* DP (동적 프로그래밍, Dynamic Programming)
* * 재귀적 DP (접근이 쉽다)
  * 반복적 DP

하지만 중요한 것은 **완전검색!** adv는 특히 더 중요하다.

* 완전검색
* * 순열 (중복)
  * 조합 (중복)
  * 부분집합
  * 배낭문제 등이 고전적이면서 대표적인 예시.

M^k(두 숫자 크기 작음) 규모는 P class.

n!, 2^n 규모는 NP class.



# 운영방식 설명

이론시간 - 졸릴만하면 코딩 시킬 것이다. 그리고 막간에 문제풀기.

실습시간 - 전날 문제 리뷰 -> 5문제   sw ex -> 코스  -> 기본 -> 파이썬

1문제(solving club)는 현장에서 끝내되 나머지 4문제(expert Problem)는 당일 자정까지 메일로 제출

메일 제목: 서울2반 날짜 이름

문제 리뷰는 그 다음 주로 미룰 것이다.



삼성 sw expert academy -> solving club -> 가입신청. 가입사유"본명"

im 추천 문제사이트 정보올림피아드.

adv 추천 문제사이트 sw expert -> learn -> course -> programming advanced



pro 문제 스타일 main이 주어지고 user code 짜야됨. 함수를 짜야하는 내용과 스펙을 말해주고 그걸 구현해야 한다.

앞의 분석, 디자인, 설계를 잘해야 디버깅이 많이 줄어든다.



# APS Python

## Array1

#### 알고리즘

알고리즘 표현 방법은 슈더코드와 순서도로 나뉜다.

슈더코드는 코딩에 가까운 모습을 보여준다.

순서도는 그림으로 개괄하기 좋으나 규모가 커지면 복잡해진다는 단점이 있다.

정규표현식이 있는 것 같다.



좋은 알고리즘의 1순위는 적은 작업량과 작업 시간.

작업시간 측정하는 방법 중 하나가 clock. 대신 작업환경에 따라 결과가 달라지는 단점.

1억번 연산이 대략 1초

![1547606174078](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1547606174078.png)



#### 배열

한 번에 다수의 변수 생성에 좋다.

Boundary를 잘못 잡아서 실수한 것에 민감하니 조심해라.

**연습 문제1**

![1547611528472](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1547611528472.png)

![1547611560140](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1547611560140.png)



#### Baby-gin Game

**설명**

* 0~9사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 **run**이라 하고, 3장의 카드가 동일한 번호를 갖는 경우는 **triplet**이라고 한다.
* 그리고, 6자의 카드가 **run**과 **triplet**로만 구성된 경우를 **baby-gin**으로 부른다.
* 6자리의 숫자를 입력 받아 **baby_gin** 여부를 판단하는 프로그램을 작성하라.

**완전 검색으로 baby-gin 접근**

6개 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)

앞의 3자리와 뒤의 3자리를 잘라 run과 triplet 여부를 테스트하고 최종적으로 baby-git 판단.



#### 완전 검색 (Exaustive Search)

* 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.
* **Brute-force** 혹은 **generate_and-test** 기법이라고도 불린다.
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
* 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
* 순열(n!), 조합(nCr), 부분집합 2^n
* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 거의 없다.
* 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알괴즘을 사용하고 해답을 확인하는 것이 바람직하다.



#### 순열 (Permutation)

* 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
* 서로 다른 n개의 r개를 택하는 순열은 다음과 같이 표현한다. **nPr**
* nPn = n! 이라고 표기하여 Factorial이라고 부른다.



#### 탐욕(Greedy) 알고리즘

* 탐욕 알고리즘은 최적해를 구하는데 사용되는 그시안적인 방법
* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
* 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현한다면  Greedy 접근이 된다.
* DT나 백트래킹보다 빠르다는 장점이 있다.

탐욕 알고리즘 동작 과정

1) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가

2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.

3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다.



#### 탐욕 알고리즘의 예) 거스름돈 줄이기

* 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄이는 방법 구하기

1) 해 선택: 여기에서는 멀리 내다볼 것 없이 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들므로 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다.

2) 실행 가능성 검사: 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 빼고, 1)로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다.

3) 해 검사: 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드려야 하는 액수와 일치하는 셈이다. 더 드려도, 덜 드려도 안되기 때문에 거스름돈을 확인해서 액수에 모자라면 다시 1)로 돌아가서 거스름돈에 추가할 동전을 고른다.

잔돈이 {5000, 1000, 500, 100, 50, 10} 이면 greedy는 정확하고 빠른 답을 준다.

하지만 잔돈이 {5, 4, 1} 이고 거슬러줘야 할 돈이 8원이면 greedy 방법은 틀렸다. 완전검색 해야한다.

그래서 좋은 그리드 알고리즘은 외워두고 비슷하게 나온 것일 때만 사용하는 것이 좋다.



#### 탐욕 알고리즘으로 Baby-gin 접근

입력 받은 6자리 숫자를 하나씩 count 세서 정리한다.

run 조사 후 run 데이터를 삭제하거나, triplet 조사 후 triplet 데이터 완전 삭제

``` python
num = 456789 # Baby Gin 확인할 6자리 수
c = [0]*12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6):
    c[num % 10] += 1
    num //= 10
i = 0
tri = run =0
while i <10:
    if c[i] >= 3: # triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:  # run 조사 후 데이터 삭제
        c [i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

it run + tri == 2: print("Baby Gin")
else: print("Lose")
```

이 코드는 triplete과 run 조사 순서를 바꾸면 틀린다. 왜냐하면 반례 [3, 1, 1, 1] 존재



#### 정렬

* 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순: ascending), 혹은 반대로의 순서대로(내림차순: descending) 재배열하는 것
* 대표적인 정렬 방식의 종류
* * 버블정렬 (Bubble Sort)
  * 카운팅 정렬 (Counting Sort)
  * 선택 정렬 (Selection Sort)
  * 퀵 정렬 (Quick Sort)
  * 삽입 정렬 (Insertion Sort)
  * 병합 정렬 (Merge Sort)



#### 버블 정렬(Bubble Sort)

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

정렬과정

* 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
* 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
* 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬

시간 복잡도 : O(n^2)

```python
def BubbleSort(a): # 정렬할 List
    for i in range(len(a)-1, 0, -1): # 범위의 끝 위치
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

병합 정렬로도 풀 수 있다.

Inversion counting.



#### 카운팅 정렬 (Counting Sort)

* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
* 제한 사항
* * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목을 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
  * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
* 사건 복잡도 : O(n+k) : n은 리스트 길이, k는 정수의 최대값

```python
def Counting_Sort(A, B, k):
# A [1 .. n] -- 입력 배열 (1 to k)
# B [1 .. n] -- 정렬된 배열.
# C [1 .. k] -- 카운트 배열.
    
    C = [0]*k
    for i in range(0, len(B)):
        C[A[i]] += 1
    for i in range (1, len(C)):
        C[i] += C[i-1]
        
    for I in range (len(B)-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= -1
```

일단 재배열할 공간을 만들어 둔다. 그리고 각 숫자마다 



* 정렬 알고리즘의 특성을 다른 정렬들과 비교

| **알고리즘** | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 |                        비고                         |
| :----------: | :-----------: | :-----------: | :-----------: | :-------------------------------------------------: |
|  버블 정렬   |    O(n^2)     |    O(n^2)     |  비교와 순환  |                 코딩이 가장 손쉽다.                 |
| 카운팅 정렬  |    O(n+k)     |    O(n+k)     |  비교한 방식  |           n이 비교적 작을 때만 가능하다.            |
|  선택 정렬   |    O(n^2)     |    O(n^2)     |  비교와 교환  |        교환의 회수가 버블,삽입정렬보다 작다.        |
|   퀵 정렬    |  O(n log n)   |    O(n^2)     |   분할 정복   | 최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠르다. |
|  삽입 정렬   |    O(n^2)     |    O(n^2)     |  비교와 교환  |           n의 개수가 작을 때 효과적이다.            |
|  병합 정렬   |  O(n log n)   |  O(n log n)   |   분할 정복   |        연결리스트의 경우 가장 효율적인 방식         |



# Solving Club 이용 안내

입력 예시를 주어진 걸 모두 실험은 해보고 싶은데, 일일히 치기엔 너무 많다?

1. 파이썬 파일과 같은 디렉토리에 input.txt 파일 생성
2. 입력 예시를 복사 붙여넣기
3. 파이썬 파일에 다음과 같은 코드를 추가 입력한다.

```python
import sys
sys.stdin = open("input.txt", "r")
```

혹은 input.txt 파일을 그대로 다운로드 받아도 된다.



#### 강변 빌딩의 조망권이 확보된 세대 수 구하기

강변에 빌딩들이 옆으로 빽빽하게 밀집한 지역이 있다.

이곳에서는 빌딩들이 너무 좌우로 밀집하여, 강에 대한 조망은 모든 세대에서 좋지만 왼쪽 또는 오른쪽 창문을 열었을 때 바로 앞에 옆 건물이 보이는 경우가 허다하였다.

그래서 이 지역에서는 왼쪽과 오른쪽으로 창문을 열었을 때, 양쪽 모두 거리 2 이상의 공간이 확보될 때 조망권이 확보된다고 말한다.

빌딩들에 대한 정보가 주어질 때, 조망권이 확보된 세대의 수를 반환하는 프로그램을 작성하시오.
 
아래와 같이 강변에 8채의 빌딩이 있을 때, 연두색으로 색칠된 여섯 세대에서는 좌우로 2칸 이상의 공백이 존재하므로 조망권이 확보된다. 따라서 답은 6이 된다.

![img](https://www.swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV2XTsoKDWIBBASl)

A와 B로 표시된 세대의 경우는 왼쪽 조망은 2칸 이상 확보가 되었지만 오른쪽 조망은 한 칸 밖에 확보가 되지 않으므로 조망권을 확보하지 못하였다.

C의 경우는 반대로 오른쪽 조망은 2칸이 확보가 되었지만 왼쪽 조망이 한 칸 밖에 확보되지 않았다.

[제약 사항]

가로 길이는 항상 1000이하로 주어진다.

맨 왼쪽 두 칸과 맨 오른쪽 두 칸에는 건물이 지어지지 않는다. (예시에서 빨간색 땅 부분)

각 빌딩의 높이는 최대 255이다.

[입력]

입력 파일의 첫 번째 줄에는 테스트케이스의 길이가 주어진다. 그 바로 다음 줄에 테스트 케이스가 주어진다.

총 10개의 테스트케이스가 주어진다.

[출력]

#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스의 조망권이 확보된 세대의 수를 출력한다.

```python
import sys
sys.stdin = open("input.txt", "r")

for t in range(10):
    building_num = int(input())
    buil = list(map(int, input().split()))

    prospect_right = 0

    for i in range(2, building_num-2):
        compare = max(buil[i-2], buil[i-1], buil[i+1], buil[i+2])
        if buil[i]>compare:
            prospect_right += buil[i]-compare

    print(f"#{t+1}", prospect_right)
```

**개선 사항**

나는 조망권이 확보됐는지 확인하는 방법으로 자신과 주변 (-2 ~ +2) 빌딩의 높이를 스캔해서 주변 빌딩의 max값을 구한 뒤 자신의 높이와 비교하여 얼마나 차이가 있는가를 세었다.

하지만, 갓규민은 max보다 sorted 방식이 더 짧은 코드로 구현되고 더 빠르다고 한다.

그런데! max는 O(n) 이지만 sort()는 O(nlogn)이다!!!    그럼에도 왜냐?!

여기선 N = 5, 즉 10 미만이기 때문에 (n > n log n) 이 되기 때문이닷!!!