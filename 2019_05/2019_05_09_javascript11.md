> # 2019.05.09

[TOC]

# 잡설

* 삼성 어플 관련 뉴스 링크들

삼성 문자혁명

[https://www.msn.com/ko-kr/news/techandscience/%EB%8B%A8%EB%8F%85-%EC%82%BC%EC%84%B1-%EB%AC%B8%EC%9E%90%ED%98%81%EB%AA%85%E2%80%A6%EC%B9%B4%ED%86%A1%EC%B2%98%EB%9F%BC-%EC%95%B1-%EC%95%88-%EA%B9%94%EC%95%84%EB%8F%84-%EB%AC%B8%EC%9E%90%EB%A1%9C-100%EB%AA%85-%EC%B1%84%ED%8C%85/ar-BBQUWqc](https://www.msn.com/ko-kr/news/techandscience/단독-삼성-문자혁명…카톡처럼-앱-안-깔아도-문자로-100명-채팅/ar-BBQUWqc)

<https://www.bloter.net/archives/328613>



앱 최적화

<https://codeday.me/ko/qa/20190324/140397.html>





* 월말평가와 최종프로젝트

월말평가가 철회됨. 하지만 최종프로젝트로 대체하기로 했다.



---

# 최종 프로젝트 안내

구글 공유 드라이브에 최소 명세서 올렸다.

최종 프로젝트 평가기준을 삼성전자에서 정해놨다.



material로 꾸며도 상관없다. vue를 아예 안써도 된다. Bootstrap 써도 된다.

머신러닝을 써도 되고, 



기능은 평범해도 극한으로 잘 꾸미면 그것도 값어치 있다.

제출은 **GitLab** 



ERD는 database 명세서라고 보면 된다.



README는 일부러 빡세게 잡으셨다. 나중에 기업에게 프로젝트 설명할 때 README가 자세할 수록 우리가 설명해야 할 분량이 줄어들기 때문에 좋다.





만약 수업을 할 거라면 채팅 앱 수업

sendbird는 외부 채팅 api 같은 건데, firebase로 구현하기 싫으면 외부걸 선택.

구글 어시스턴트는 의무사항 아니지만,



---

# 10, 11번째 프로젝트

* 10번째 프로젝트 - API 서버 구축

  c9에 새 프로젝트를 생성하여 API 서버 구축

* 11번째 프로젝트 - Vue SPA

  로컬 컴퓨터에서 html, javascript를 이용하여 클라이언트 페이지 생성



---

## API 서버 구축

### -1 환경 구성 및 프로젝트, 앱 생성

**pyenv 설치**

아래 코드를 bash 창에 입력

```python
git clone https://github.com/pyenv/pyenv.git ~/.pyenv
echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init -)"\nfi' >> ~/.bashrc
exec "$SHELL"

git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv
echo 'eval "$(pyenv virtualenv-init -)"' >> ~/.bashrc
exec "$SHELL"
```



**python 3.6.7 설치**

작업이 오래 걸리는게 특징.

```bash
$ pyenv install 3.6.7
Downloading Python-3.6.7.tar.xz...
-> https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tar.xz
Installing Python-3.6.7...
Installed Python-3.6.7 to /home/ubuntu/.pyenv/versions/3.6.7
$ pyenv global 3.6.7
$ python --version
Python 3.6.7
```



**폴더 생성 및 가상환경 설치**

proj11  폴더 설치하여 가상환경을 조성한다.

```bash
$ mkdir proj11
$ cd proj11/
$ pyenv virtualenv 3.6.7 proj11-venv
Looking in links: /tmp/tmp37wzj5zv
Requirement already satisfied: setuptools in /home/ubuntu/.pyenv/versions/3.6.7/envs/proj11-venv/lib/python3.6/site-packages (39.0.1)
Requirement already satisfied: pip in /home/ubuntu/.pyenv/versions/3.6.7/envs/proj11-venv/lib/python3.6/site-packages (10.0.1)
$ pyenv local proj11-venv
```



**Django 설치**

```bash
$ pip install --upgrade pip
$ pip install django==2.1.8
```



**프로젝트 생성 및 앱 추가**

```bash
$ django-admin startproject api .
$ python manage.py startapp movies
```



**settings.py 설정**

```python
ALLOWED_HOSTS = ['*']
INSTALLED_APPS = [
    ...
    'movies',
]
TIME_ZONE = 'Asia/Seoul'
```



**root urls.py**

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/', include('movies.urls'))
]
```



---

### -2 DB 생성

**movies/models.py**

클래스 생성 순서는 장르 - 영화 - 평점이다.

ForeignKey 때문에 위 순서를 지키지 않으면 undefined 에러가 발생.

```python
from django.db import models

class Genre(models.Model):
    name = models.CharField(max_length=20)
    
    def __str__(self):
        return self.name


class Movie(models.Model):
    title = models.CharField(max_length=30)
    audience = models.IntegerField()
    poster_url = models.CharField(max_length=100)
    description = models.TextField()
    genre = models.ForeignKey(Genre, on_delete=models.CASCADE)
    
    def __str__(self):
        return self.name


class Score(models.Model):
    content = models.CharField(max_length=80)
    score = models.IntegerField()
    movie = models.ForeignKey(Movie, on_delete=models.CASCADE)
    
    def __str__(self):
        return self.content
```

`makemigrations` , `migrate` 작업을 해준다.



**Seed Data 반영**

주어진 JSON 파일 2개를 movies 앱에 fixtures라는 디렉토리 생성하여 넣는다.

아래 명령어로 데이터를 주입한다.

```bash
$ python manage.py loaddata genre.json
Installed 11 object(s) from 1 fixture(s)
$ python manage.py loaddata movie.json
Installed 10 object(s) from 1 fixture(s)
```



**shell plus로 확인하기**

django-extensions를 설치하고 shell plus로 DB상태를 살핀다.

```bash
$ pip install django-extensions
```

settings.py에 앱 추가

```python
INSTALLED_APPS = [
    ...
    'movies',
    'django_extensions',
]
```

shell plus 실행한 후 아무거나 출력해본다.

```bash
$ python manage.py shell_plus
>>> Genre.objects.first().name
'가족'
>>> quit()
```

주입은 완벽하게 됐다.



---

### -3 API 요청 - 장르 출력

**djangorestframework 설치**

REST API를 구현하기 위해선 djangorestframework가 필요하다

```bash
$ pip install djangorestframework
```

settings.py에 등록. 앱 이름이 'rest_framework' 인 것을 명심.

```python
INSTALLED_APPS = [
    ...
    'movies',
    'django_extensions',
    'rest_framework',
]
```



**movies/serializer.py - 생성**

Django DB가 가지고 있는 데이터를 JSON으로 parsing하여 보내기 위해 생성.

```python
from rest_framework import serializers
from .models import Genre, Movie, Score


class GenreSerilizer(serializers.ModelSerializer):
    class Meta:
        model = Genre
        fields = ['id', 'name']
```



**movies/urls.py - 추가**

 /api/v1/genres/ 주소로 요청하면 genres_list views 연결.

```python
from django.urls import path
from . import views

app_name = 'movies'

urlpatterns = [
    path('genres/', views.genres_list, name="genres_list"),
]
```



**movies/views.py - genres_list**

DB에 저장된 모든 genre에 대한 데이터를 뽑아온다.

이를 rest_framework가 제공하는 JSON 파싱작업을 이용한다.

Response는 JSON을 응답해주겠다는 뜻.

단, django는 rest framework의 method를 스스로 읽지 못해서 get, post, put, delete 등을 인지하지 못한다. 따라서 django rest framework가 지원하는 api_view를 이용해야 한다. 이로써 django는 어떤 http method를 사용할지 알 수 있게 된다.

```python
from django.shortcuts import render, get_object_or_404
from .models import Genre, Movie, Score
from rest_framework.response import Response
from rest_framework.decorators import api_view
from .serializer import GenreSerilizer


@api_view(['GET'])
def genres_list(request):
    genres = Genre.objects.all()
    serializer = GenreSerilizer(genres, many=True)
    return Response(data=serializer.data)
```



**서버 돌려서 결과 관찰**

해당 url에 접속하면 아래와 같은 JSON이 출력.

```json
[
    {
        "id": 1,
        "name": "가족"
    },
    {
        "id": 2,
        "name": "공포(호러)"
    },
    ...
    {
        "id": 11,
        "name": "코미디"
    }
]
```



---

### -4 API 요청 - 해당 장르가 포함하는 영화 출력

`GET /api/v1/genres/{genre_pk}` 에 접속하면 JSON형태로 [장르id, 해당영화 정보] 형식으로 출력해야한다.

아래 사이트 참조 (Nested relationships)

<https://nl.hideproxy.me/go.php?u=5h20yI5izpvCQZ6WiVKPFea%2B32bjE2ibNjdnqNGNG8s8y6QJ7G%2Fx0jHOI%2BrYVMPnSoWc0tsL&b=5&f=norefer>



**movies/serializer.py - GenreMovieSerilizer**

movies 받아오는 메뉴열



```python
class GenreMovieSerilizer(serializers.ModelSerializer):
    movies = MovieSerilizer(many=True, read_only=True)

    class Meta:
        model = Genre
        fields = ('id', 'movies')
```



**movies/urls.py**





**movies/views.py - genre_movies**





---

## Vue

vue가 잘 안 만들어질 것이다.

리스트랑 상세보기 등을 한 페이지에 구현하려니 여간 까다로운게 아니다.

그래서 뷰 라우터를 이용해서 다른 페이지를 이동해서 해결할 수 있는데, 이게 배우려면 1달 이상 걸린다.

그래서 강사님께서 직접 뼈대만 작성해주셔서 파일을 올려주심. 뼈대를 이어서 vue를 작성하면 된다.



